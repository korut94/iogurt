#ifndef HUMAN_H
#define HUMAN_H

#include "../command/commandqueue.s3d"
#include "../scene/interactionray.s3d"
#include "../scene/object.s3d"
#include "../scene/physics/rigidbody.s3d"
#include "def.s3d"
#include "view.s3d"
#include "gadget/selectionray.s3d"

class Human
{
	var m_character;
	var m_eye;
	var m_queue;
	var m_selector;
	
	applyTo(world);
	getCommandQueue();
	getView();
	/*
	 * @brief Initialiaze the trasformation of the human parts. Any settings in the
	 * constructor's body will be missed since when the world attaches the parts
	 * in its tree, their transformation are resetted. 
	 */
	init();
	processCommands();
	processCommand(command);
};

function Human::Human() {
	m_queue = CommandQueue();
	m_eye = CVmObj();
	
	m_character = Array(N_PARTS);
	m_character[BODY_ID] = Object();
	m_character[BODY_ID].linkToBody(RigidBody());
	m_character[HEAD_ID] = Object();
	m_character[HEAD_ID].linkToBody(RigidBody());
	
	// Block the head to the body
	m_character[BODY_ID].getCVmObj().AddChild(m_character[HEAD_ID].getCVmObj());
	m_character[HEAD_ID].getCVmObj().AddChild(m_eye);
	
	// Starting the min conrner from the origin allow the definition of the box writing
	// the max cornser as: [width, heigth, depth]. Then, the correct position is setted
	// by the CVmObj's methods.
	var meshBody = CVmNewMesh(VRP_BOX, 0, [0,0,0], [5,5,3]);
	meshBody.CenterBoundingBox();
	var meshHead = CVmNewMesh(VRP_BOX, 0, [0,0,0], [3,3,1]);
	meshHead.CenterBoundingBox();
	
	m_character[BODY_ID].getCVmObj().LinkToMesh(meshBody);
	m_character[HEAD_ID].getCVmObj().LinkToMesh(meshHead);
	
	m_selector = SelectionRay(m_character[HEAD_ID].getCVmObj());
}

function Human::applyTo(world) {
	world.addRootToDraw(m_character[BODY_ID].GetCVmObj());
	
	foreach (var part in m_character) {
		world.trackObject(part);
	}
	
	m_selector.applyTo(world);
}

function Human::getCommandQueue() {
	return m_queue;
}

function Human::getView() {
	var trEye = m_eye.GetModelMatrix();
	
	var pView = View();
	// Get traslation component, the last column of the matrix.
	pView.position = [trEye[12], trEye[13], trEye[14]];
	// Get the normalized vector for Z axis
	pView.direction = [trEye[8], trEye[9], trEye[10]];
	
	return pView;
}

function Human::init() {
	m_character[BODY_ID].getCVmObj().setPosition([0, 1, 0]);
	// The head's position is: one more right, one more up and one more ahead respect the body
	// size. The value are relative to the size of the body's mesh!
	m_character[HEAD_ID].getCVmObj().SetPosition([0, 5, 0]);
	// m_eye.setPosition([-5, 0, -23]);
	m_selector.init();
}

function Human::processCommand(command) {
	command.action().apply(m_character[command.target()]);
}

function Human::processCommands() {
	while (!m_queue.isEmpty()) {
		processCommand(m_queue.pop());
	}
}

#endif // HUMAN_H
