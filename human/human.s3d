#ifndef HUMAN_H
#define HUMAN_H

#include "../scene/object.s3d"
#include "../scene/utility.s3d"
#include "../scene/physics/rigidbody.s3d"
#include "view.s3d"
#include "action/move.s3d"

#define N_PARTS 2

#define BODY_ID 	0x00
#define HEAD_ID		0x01

class Human
{
	var m_character;
	var m_eye;
	var m_queue;
	
	applyTo(world);
	getPart(id);
	getView();
	/*
	 * @brief Initialiaze the trasformation of the human parts. Any settings in the
	 * constructor's body will be missed since when the world attaches the parts
	 * in its tree, their transformation are resetted. 
	 */
	init();
	registerTo(dispatcher);
};

function Human::Human() {
	m_eye = CVmObj();
	
	m_character = Array(N_PARTS);
	m_character[BODY_ID] = Object();
	m_character[BODY_ID].linkToBody(RigidBody());
	m_character[HEAD_ID] = Object();
	m_character[HEAD_ID].linkToBody(RigidBody());
	
	// Block the head to the body
	m_character[BODY_ID].getCVmObj().AddChild(m_character[HEAD_ID].getCVmObj());
	m_character[HEAD_ID].getCVmObj().AddChild(m_eye);
	
	// Starting the min conrner from the origin allow the definition of the box writing
	// the max cornser as: [width, heigth, depth]. Then, the correct position is setted
	// by the CVmObj's methods.
	var meshBody = CVmNewMesh(VRP_BOX, 0, [0,0,0], [5,5,3]);
	meshBody.CenterBoundingBox();
	var meshHead = CVmNewMesh(VRP_BOX, 0, [0,0,0], [3,3,1]);
	meshHead.CenterBoundingBox();
	
	m_character[BODY_ID].getCVmObj().LinkToMesh(meshBody);
	m_character[HEAD_ID].getCVmObj().LinkToMesh(meshHead);
}

function Human::applyTo(world) {
	world.addRootToDraw(m_character[BODY_ID].GetCVmObj());
	
	foreach (var part in m_character) {
		world.trackObject(part);
	}
}

function Human::getPart(id) {
	return m_character[id];
}

function Human::getView() {
	var pView = View();
	// Get traslation component, the last column of the matrix.
	pView.position = globalPosition(m_eye);
	// Get the normalized vector for Z axis
	pView.direction = direction(m_eye);
	
	return pView;
}

function Human::init() {
	m_character[BODY_ID].getCVmObj().setPosition([0, 1, 0]);
	// The head's position is: one more right, one more up and one more ahead respect the body
	// size. The value are relative to the size of the body's mesh!
	m_character[HEAD_ID].getCVmObj().SetPosition([0, 5, 0]);
	// m_eye.setPosition([-5, 0, -23]);
}

function Human::registerTo(dispatcher) {
	dispatcher.on("KeyPressed_S", Move(m_character[BODY_ID], -0.1));
	dispatcher.on("KeyPressed_W", Move(m_character[BODY_ID], 0.1));
	dispatcher.on("KeyReleased_S", Move(m_character[BODY_ID], 0));
	dispatcher.on("KeyReleased_W", Move(m_character[BODY_ID], 0));
}

#endif // HUMAN_H
