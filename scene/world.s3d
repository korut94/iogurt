#ifndef WORLD_H
#define WORLD_H

#include "../command/commandqueue.s3d"

function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, -1, max);
			glVertex(i, -1, min);
			
			glVertex(max, -1, i);
			glVertex(min, -1, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}

class World
{
	var m_objectList;
	var m_queue;
	var m_rayList;
	var m_root;
	
	addInteractionRay(ray);
	/*
	 * @brief Add the root of a CVmObj to draw all its children and itself
	 */
	addRootToDraw(root);
	checkCollisions();
	draw();
	getCommandQueue();
	/*
	 * @brief Attaching the object to update it and check its collision with
	 * the other objects in the scene.
	 */
	trackObject(object);
	update();
};

function World::World() {
	m_objectList = {};
	m_queue = CommandQueue();
	m_rayList = {};
	m_root = CVmObj();
}

function World::addInteractionRay(ray) {
	aadd(m_rayList, ray);
}

function World::addRootToDraw(root) {
	m_root.AddChild(root);
}

function World::checkCollisions() {
	foreach (var ray in m_rayList) {
		var i = 0;
		var goAhead = true;
		
		while (goAhead) {
			i += 1;
			goAhead = i < len(m_objectList) && (
				!ray.seesObj(m_objectList[i].getCVmObj())  
				|| !m_objectList[i].getCVmObj().isColliding(ray.from(), ray.to()));
		}
		
		// There is at least an object selected by the ray and this object is in the
		// i-est position of m_objectList
		if (i < len(m_objectList)) {
			var target = m_objectList[i];
			
			for (var j = i + 1; j < len(m_objectList); j++) {
				var object = m_objectList[j];
				
				if (ray.seesObj(object.getCVmObj())
					// Ignore any objects behind the target but collided by the ray
					&& ray.distanceFrom(object.getCVmObj()) < ray.distanceFrom(target.getCVmObj())
					&& object.getCVmObj().isColliding(ray.from(), ray.to())
				) {
					target = object;
				}
			}
			
			ray.getBehavior().onCollision(target);
		}
	}
}

function World::draw() {
	glClearColor(1.0, 1.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	DrawGrid([0.5, 0.5, 0.5], 100);
	m_root.Draw();
}

function World::getCommandQueue() {
	return m_queue;
}

function World::trackObject(object) {
	aadd(m_objectList, object);
}

function World::update() {
	while (!m_queue.isEmpty()) {
		m_queue.pop().apply();
	}
	
	foreach (var object in m_objectList) {
		object.update();
	}
	
	checkCollisions();
}

#endif // WORLD_H
