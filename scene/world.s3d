#ifndef WORLD_H
#define WORLD_H

function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, -1, max);
			glVertex(i, -1, min);
			
			glVertex(max, -1, i);
			glVertex(min, -1, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}

class World
{
	var m_objectList;
	var m_rayList;
	var m_root;
	
	addInteractionRay(ray);
	/*
	 * @brief Add the root of a CVmObj to draw all its children and itself
	 */
	addRootToDraw(root);
	checkCollisions();
	draw();
	/*
	 * @brief Attaching the object to update it and check its collision with
	 * the other objects in the scene.
	 */
	trackObject(object);
	update();
};

function World::World() {
	m_objectList = {};
	m_rayList = {};
	m_root = CVmObj();
}

function World::addInteractionRay(ray) {
	aadd(m_rayList, ray);
}

function World::addRootToDraw(root) {
	m_root.AddChild(root);
}

function World::checkCollisions() {
	foreach (var ray in m_rayList) {
		foreach (var object in m_objectList) {
			if (object.getCVmObj().isColliding(ray.from(), ray.to())) {
				object.getBehavior().onCollision(ray);
				ray.getBehavior().onCollision(object);
			}
		}
	}
}

function World::draw() {
	glClearColor(1.0, 1.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	DrawGrid([0.5, 0.5, 0.5], 100);
	m_root.Draw();
}

function World::trackObject(object) {
	aadd(m_objectList, object);
}

function World::update() {
	foreach (var object in m_objectList) {
		object.update();
	}
	
	checkCollisions();
}

#endif // WORLD_H
