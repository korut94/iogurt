#ifndef WORLD_H
#define WORLD_H

#define MAX_NUMBER_OBJECTS 1000

function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, -1, max);
			glVertex(i, -1, min);
			
			glVertex(max, -1, i);
			glVertex(min, -1, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}

class World
{
	var m_lastIndexObj;
	var m_objList;
	var m_root;
	
	addObject(obj);
	checkCollisions();
	draw();
	update();
};

function World::World() {
	m_objList = Array(MAX_NUMBER_OBJECTS);
	m_root = CVmObj();
	
	m_lastIndexObj = 0;
}

function World::addObject(obj) {
	m_root.AddChild(obj.getCVmObj());
	m_objList[m_lastIndexObj++] = obj;
}

function World::checkCollisions() {
	for (var i = 0; i < m_lastIndexObj; i++) {
		for (var j = i + 1; j < m_lastIndexObj; j++) {
			if (m_objList[i].getCVmObj().IsCollidingBBox(m_objList[j].getCVmObj())) {
				m_objList[i].getBehavior().onCollide(m_objList[j]);
				m_objList[j].getBehavior().onCollide(m_objList[i]);
			}
		}
	}
}

function World::draw() {
	glClearColor(1.0, 1.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	DrawGrid([0.5, 0.5, 0.5], 100);
	m_root.Draw();
}

function World::update() {
	for (var i = 0; i < m_lastIndexObj; i++) {
		m_objList[i].update();
	}
	
	checkCollisions();
}

#endif // WORLD_H
