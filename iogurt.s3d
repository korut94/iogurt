/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>

#define SIZE_COMMAND_QUEUE 100

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;

/* Player */
var __player;

/* All variabile to manage the command queue */
// Index reached by the insertion of the new command
var __last_command = 0;
// The command queue itself
var __command_queue = Array(SIZE_COMMAND_QUEUE);

/* Camera globals */
var step = 0;
var RotX= 0, RotY=0; 
var CamDir = [0,0,1];		//camera direction
var CamPos = [0.0,1.0,10.0];  	//camera position
/* Light globals */
var Light0;
var PosL = [0.0, 10.0, 10.0];	// default light position

#include "device/default.s3d"
#include "player.s3d"

/* Function declarations */
function CameraMoveMouse();
function DrawGrid(col, size);
function updateView(view);

function OnInit(params)
{
	/* initialize light */
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	Light0.SetDiffuse(1, 1, 1);
	Light0.Enable();
	
	__player = Player([0.0,1.0,-10.0]);
}

function OnFrame()
{
	/* manage camera */
	updateView(__player.getView());
	
	SceneBegin();
	glClearColor(1.0, 1.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	
	DrawGrid([0.5, 0.5, 0.5], 100);
	
	glBegin(GL_QUADS);
	glNormal(0,0,1);
	glVertex(1.0,1.0,1.0);
	glVertex(-1.0,1.0,1.0);
	glVertex(-1.0,-1.0,1.0);
	glVertex(1.0,-1.0,1.0);
	
	glNormal(0,0,-1);
	glVertex(-1.0,1.0,-1.0);
	glVertex(1.0,1.0,-1.0);
	glVertex(1.0,-1.0,-1.0);
	glVertex(-1.0,-1.0,-1.0);
	
	glNormal(1,0,0);
	glVertex(1.0,1.0,1.0);
	glVertex(1.0,-1.0,1.0);
	glVertex(1.0,-1.0,-1.0);
	glVertex(1.0,1.0,-1.0);
	
	glNormal(-1,0,0);
	glVertex(-1.0,-1.0,1.0);
	glVertex(-1.0,1.0,1.0);
	glVertex(-1.0,1.0,-1.0);
	glVertex(-1.0,-1.0,-1.0);
	
	glNormal(0,1,0);
	glVertex(1.0,1.0,-1.0);
	glVertex(-1.0,1.0,-1.0);
	glVertex(-1.0,1.0,1.0);
	glVertex(1.0,1.0,1.0);
	glEnd();
	
	SceneEnd();
}

function OnTimer()
{
	__player.processCommands(__command_queue, __last_command, SIZE_COMMAND_QUEUE);
	
	SetCursorPos(0.5, 0.5);
}

function OnEvent(eventID, wparam, lparam)
{
	var command = deviceTranslation(eventID, wparam, lparam);
	
	// Any command in ignored status will be rejected
	if (command[COMMAND_STATUS] != STATUS_IGNORED) {
		__command_queue[__last_command++] = command;
	
		// Make a circular list so to skip any cleaning phase
		if (__last_command == SIZE_COMMAND_QUEUE) {
			__last_command = 0;
		}	
	}
	
	// TODO: to implement a simple message system to alert the user that
	// an event dosen't have un corrispetive command. 
}

function updateView(view) {
	CameraSetPosition(view.position);
	CameraSetDirection(view.direction);
}

function DownloadReady(RequestID) {}
function OnDownload() {}
function OnError(){}
function OnExit() {}

// Camera manager (using mouse)
function CameraMoveMouse()
{
	static var InMouseR = false, InMouseL = false;				
	static var PrecX = 0, PrecY = 0;			
	if(Mouse.ButtonL)
  	{
  		if( InMouseL )
   		{
		    Rotx += (Mouse.X - PrecX)/50.0;
		    Roty += (Mouse.Y - PrecY)/50.0;
		    CameraSetRotation(Roty, 1,0,0);
		    CameraRotate(Rotx , 0,1,0 );
		   }
	  	else
   		{
	   		PrecX = Mouse.X;
   			PrecY = Mouse.Y;
   		}
 	 	InMouseL = true;
  	}
 	else
  		InMouseL = false;

 	if(Mouse.ButtonR)
  	{
  		if( InMouseR )
   		{
   			CamPos = CameraGetPosition();
   			CamDir = CameraGetDirection();
   			step = ( PrecY - Mouse.Y) /150.0; 
			CamPos[0] += step*CamDir[0];
			CamPos[1] += step*CamDir[1];
			CamPos[2] += step*CamDir[2];
   			CameraSetPosition( CamPos );
    		}
  		else
   		{
			PrecX = Mouse.X;
			PrecY = Mouse.Y;
   		}
		InMouseR = true;
  	}
	else
		InMouseR = false;
}


function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}
