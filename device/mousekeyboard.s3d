#ifndef MOUSE_KEYBOARD_H
#define MOUSE_KEYBOARD_H

#define LINE_CONSTANT 	0x10000
#define MOUSE_MOVE 		0x0200

#define KEY_PRESSED 	0x0100
#define KEY_RELEASED	0x0101
#define KEY_TAPPED		0x0102
#define KEY_A			0x41	
#define MAP_KEY_A 		0x00
#define KEY_D			0x44	
#define MAP_KEY_D 		0x01
#define KEY_S			0x53	
#define MAP_KEY_S 		0x02
#define KEY_W			0x57	
#define MAP_KEY_W 		0x03
#define COUNT_MAP_KEY	4

#define ANGLE_SPEED		0.5

#define WM_BORDER		11

#include "../command/command.s3d"
#include "../command/move.s3d"
#include "../command/rotate.s3d"
#include "../human/def.s3d"

class MouseKeyboard
{	
	/*
	 * @brief The keyboard status, when an item is true meaning that the relative
	 * key is hold pressed.
	 */
	var m_kbStatus;
	
	/*
	 * @brief The function will be invoked by the application when all events
	 * have been processed.
	 */
	restart();
	/*
	 * @brief The function translates all events relative to the mouse and 
	 * keyboard in human interaction commands.
	 * 
	 * @return The tuple (status : bool, target : int, command : Command). 
	 * If `status` is false so the event was ignored and the value of 
	 * `command` is void, otherwise `command` reppresents the correct command
	 * to apply.
	 */
	translate(eventId, wparam, lparam, window);
};

function MouseKeyboard::MouseKeyboard() {
	m_kbStatus = Array(COUNT_MAP_KEY);
	
	m_kbStatus[MAP_KEY_A] = false;
	m_kbStatus[MAP_KEY_S] = false;
	m_kbStatus[MAP_KEY_D] = false;
	m_kbStatus[MAP_KEY_W] = false;
}

function MouseKeyboard::restart() {
	SetCursorPos(0.5, 0.5);
}

function MouseKeyboard::translate(eventId, wparam, lparam, window) {
	var cmd;
	
	if (eventId == KEY_PRESSED) {
		switch (wparam) {
			case KEY_D: {
				cmd = (m_kbStatus[MAP_KEY_D]) ? CmdIgnore() : Command(Move(0.1, [1, 0, 0]), BODY_ID);
				m_kbStatus[MAP_KEY_D] = true;
				break;
			}
			case KEY_A: {
				cmd = (m_kbStatus[MAP_KEY_A]) ? CmdIgnore() : Command(Move(0.1, [-1, 0, 0]), BODY_ID); 
				m_kbStatus[MAP_KEY_A] = true;
				break;
			}
			case KEY_W: {
				cmd = (m_kbStatus[MAP_KEY_W]) ? CmdIgnore() : Command(Move(0.1, [0, 0, 1]), BODY_ID);
				m_kbStatus[MAP_KEY_W] = true;
				break;
			}
			case KEY_S: {
				cmd = (m_kbStatus[MAP_KEY_S]) ? CmdIgnore() : Command(Move(0.1, [0, 0, -1]), BODY_ID);
				m_kbStatus[MAP_KEY_S] = true;
				break;
			}
			default: cmd = CmdIgnore();
		}
	// The second condition need to avoid the false positive by the keyboard repetition
	} else if (eventId == KEY_RELEASED && !KeyPressed(wparam)) {
		switch (wparam) {
			case KEY_D: {
				cmd = Command(Move(0, [1, 0, 0]), BODY_ID);
				m_kbStatus[MAP_KEY_D] = false;
				break;
			}
			case KEY_A: {
				cmd = Command(Move(0, [-1, 0, 0]), BODY_ID); 
				m_kbStatus[MAP_KEY_A] = false;
				break;
			}
			case KEY_W: {
				cmd = Command(Move(0, [0, 0, 1]), BODY_ID);
				m_kbStatus[MAP_KEY_W] = false;
				break;
			}
			case KEY_S: {
				cmd = Command(Move(0, [0, 0, -1]), BODY_ID);
				m_kbStatus[MAP_KEY_S] = false;
				break;
			}
			default: cmd = CmdIgnore();
		}
	} else if (eventId == MOUSE_MOVE) {
		var offX = window.getSize().x()/2;
		// The eleven is the possible width of the window's border
		var offY = window.isFullScreen() ? window.getSize().y()/2 : (window.getSize().y()/2) - WM_BORDER;
		
		cmd = Command(Rotate(-(Mouse.X - offX) * ANGLE_SPEED, -(Mouse.Y - offY) * ANGLE_SPEED), BODY_ID);
	} else {
		cmd = CmdIgnore();
	}
	
	return cmd;
}

#endif // MOUSE_KEYBOARD_H
