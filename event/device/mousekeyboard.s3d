#ifndef MOUSE_KEYBOARD_H
#define MOUSE_KEYBOARD_H

#define LINE_CONSTANT 	0x10000
#define MOUSE_MOVE 		0x0200

#define KEY_PRESSED 	0x0100
#define KEY_RELEASED	0x0101
#define KEY_TAPPED		0x0102
#define KEY_A			0x41	
#define MAP_KEY_A 		0x00
#define KEY_D			0x44	
#define MAP_KEY_D 		0x01
#define KEY_S			0x53	
#define MAP_KEY_S 		0x02
#define KEY_V			0x56
#define MAP_KEY_V		0x03
#define KEY_W			0x57	
#define MAP_KEY_W 		0x04
#define COUNT_MAP_KEY	5

#define WM_BORDER		11

#include "../channel.s3d"
#include "driver.s3d"

class MouseKeyboard : Driver
{	
	var m_chKeyAPressed;
	var m_chKeyDPressed;
	var m_chKeySPressed;
	var m_chKeyVPressed;
	var m_chKeyWPressed;
	
	var m_chKeyAReleased;
	var m_chKeyDReleased;
	var m_chKeySReleased;
	var m_chKeyVReleased;
	var m_chKeyWReleased;
	
	var m_chMouseMove;
	
	/*
	 * @brief The keyboard status, when an item is true meaning that the relative
	 * key is hold pressed.
	 */
	var m_kbStatus;
	
	/*
	 * @brief The function translates all events relative to the mouse and 
	 * keyboard in human interaction commands and it pushes their into the
	 * queue commands.
	 */
	processEvent(eventId, wparam, lparam, queue, window);
	updateChannelList(list);
};

function MouseKeyboard::MouseKeyboard() {
	m_kbStatus = Array(COUNT_MAP_KEY);
	
	m_kbStatus[MAP_KEY_A] = false;
	m_kbStatus[MAP_KEY_S] = false;
	m_kbStatus[MAP_KEY_D] = false;
	m_kbStatus[MAP_KEY_V] = false;
	m_kbStatus[MAP_KEY_W] = false;
	
	m_chKeyAPressed		= Channel("KeyPressed_A");
	m_chKeyDPressed 	= Channel("KeyPressed_D");
	m_chKeySPressed		= Channel("KeyPressed_S");
	m_chKeyVPressed		= Channel("KeyPressed_V");
	m_chKeyWPressed 	= Channel("KeyPressed_W");
	m_chKeyAReleased	= Channel("KeyReleased_A");
	m_chKeyDReleased 	= Channel("KeyReleased_D");
	m_chKeySReleased	= Channel("KeyReleased_S");
	m_chKeyVReleased	= Channel("KeyReleased_V");
	m_chKeyWReleased 	= Channel("KeyReleased_W");
	m_chMouseMove		= Channel("MouseMove");
}

function MouseKeyboard::processEvent(eventId, wparam, lparam, queue, window) {
	if (eventId == KEY_PRESSED) {
		switch (wparam) {
			case KEY_A: {
				if (!m_kbStatus[MAP_KEY_A]) m_chKeyAPressed.trigger(queue);
				m_kbStatus[MAP_KEY_A] = true;
				break; 
			}
			
			case KEY_D: {
				if (!m_kbStatus[MAP_KEY_D]) m_chKeyDPressed.trigger(queue);
				m_kbStatus[MAP_KEY_D] = true;
				break; 
			}
			
			case KEY_S: {
				if (!m_kbStatus[MAP_KEY_S]) m_chKeySPressed.trigger(queue);
				m_kbStatus[MAP_KEY_S] = true;
				break; 
			}
			
			case KEY_V: {
				if (!m_kbStatus[MAP_KEY_V]) m_chKeyVPressed.trigger(queue);
				m_kbStatus[MAP_KEY_V] = true;
				break;
			}
			
			case KEY_W: {
				if (!m_kbStatus[MAP_KEY_W]) m_chKeyWPressed.trigger(queue);
				m_kbStatus[MAP_KEY_W] = true;
				break;
			}
		}
	// The second condition need to avoid the false positive by the keyboard repetition
	} else if (eventId == KEY_RELEASED && !KeyPressed(wparam)) {
		switch (wparam) {
			case KEY_A: {
				m_chKeyAReleased.trigger(queue);
				m_kbStatus[MAP_KEY_A] = false;
				break;
			}
			
			case KEY_D: {
				m_chKeyDReleased.trigger(queue);
				m_kbStatus[MAP_KEY_D] = false;
				break;
			}
			
			case KEY_S: {
				m_chKeySReleased.trigger(queue);
				m_kbStatus[MAP_KEY_S] = false;
				break;
			}
			
			case KEY_V: {
				m_chKeyVReleased.trigger(queue);
				m_kbStatus[MAP_KEY_V] = false;
				break;
			}
			
			case KEY_W: {
				m_chKeyWReleased.trigger(queue);
				m_kbStatus[MAP_KEY_W] = false;
				break;
			}
		}
	} else if (eventId == MOUSE_MOVE) {
		m_chMouseMove.trigger(queue, {Mouse.X, Mouse.Y, window});
		/* 
		 * var offX = window.getSize().x()/2;
		 * var offY = window.isFullScreen() ? window.getSize().y()/2 : (window.getSize().y()/2) - WM_BORDER;
		 * queue.push(Command(Rotate(-(Mouse.X - offX) * ANGLE_SPEED, 0), BODY_ID));
		 * queue.push(Command(Rotate(0, (Mouse.Y - offY) * 0.4), HEAD_ID));
		 */
	} else {
		m_next.processEvent(eventId, wparam, lparam, queue, window);	
	}
}

/*
function MouseKeyboard::restart() {
	SetCursorPos(0.5, 0.5);
}
*/

function MouseKeyboard::updateChannelList(list) {
	aadd(list, m_chKeyAPressed);
	aadd(list, m_chKeyDPressed);
	aadd(list, m_chKeySPressed);
	aadd(list, m_chKeyVPressed);
	aadd(list, m_chKeyWPressed);
	aadd(list, m_chKeyAReleased);
	aadd(list, m_chKeyDReleased);
	aadd(list, m_chKeySReleased);
	aadd(list, m_chKeyVReleased);
	aadd(list, m_chKeyWReleased);
	aadd(list, m_chMouseMove);
}

#endif // MOUSE_KEYBOARD_H
